<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="0. 写在前面：表面上, 本文讨论的问题是十分简单的, 谁都能想到一个看似没问题的划分方法 但是, 如果想要找寻一种最佳的方式, 应对各种情况下的比率, 将所有元素都不遗漏地划分, 并非一个简单的问题, 由于元素总数是整数, 而比率是浮点数, 我们想到的办法或多或少会丢失遗漏元素, 或者造成某个划分区间为空, 在这种情况下, 我们首先需要判断, 如何的划分是最佳划分, 然后给出必定可以产生最佳划分">
<meta property="og:type" content="article">
<meta property="og:title" content="讨论-将列表所有元素按照指定的比率进行划分">
<meta property="og:url" content="http://example.com/2022/07/08/data_dividing/index.html">
<meta property="og:site_name" content="纯洁的小火车">
<meta property="og:description" content="0. 写在前面：表面上, 本文讨论的问题是十分简单的, 谁都能想到一个看似没问题的划分方法 但是, 如果想要找寻一种最佳的方式, 应对各种情况下的比率, 将所有元素都不遗漏地划分, 并非一个简单的问题, 由于元素总数是整数, 而比率是浮点数, 我们想到的办法或多或少会丢失遗漏元素, 或者造成某个划分区间为空, 在这种情况下, 我们首先需要判断, 如何的划分是最佳划分, 然后给出必定可以产生最佳划分">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-07T16:54:30.300Z">
<meta property="article:modified_time" content="2022-07-07T16:58:01.007Z">
<meta property="article:author" content="Pu Zhao">
<meta property="article:tag" content="Math Python Tensorflow Pytorch GAN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/07/08/data_dividing/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>讨论-将列表所有元素按照指定的比率进行划分 | 纯洁的小火车</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">纯洁的小火车</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/08/data_dividing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pu Zhao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="纯洁的小火车">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          讨论-将列表所有元素按照指定的比率进行划分
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-08 00:54:30 / 修改时间：00:58:01" itemprop="dateCreated datePublished" datetime="2022-07-08T00:54:30+08:00">2022-07-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="0-写在前面："><a href="#0-写在前面：" class="headerlink" title="0. 写在前面："></a>0. 写在前面：</h2><p>表面上, 本文讨论的问题是十分简单的, 谁都能想到一个看似没问题的划分方法</p>
<p>但是, 如果想要找寻一种<code>最佳</code>的方式, 应对各种情况下的<code>比率</code>, 将所有元素都不遗漏地划分, 并非一个简单的问题, 由于元素总数是整数, 而<code>比率</code>是浮点数, 我们想到的办法或多或少会丢失遗漏元素, 或者造成某个划分区间为空, 在这种情况下, 我们首先需要判断, 如何的划分是<code>最佳</code>划分, 然后给出必定可以产生最佳划分的算法, 给出适当的优化</p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述:"></a>1. 问题描述:</h2><p>一个长度为N的列表(存在N个元独立元素), 被n个比例的列表rates划分为n个区间,满足条件:<br>$$<br>\begin{aligned}<br>&amp;n,N \in \mathbb{Z^+},<del>1\leq n \leq N\<br>&amp;rates &#x3D; [r_{1},r_{2},r_{3},…,r_{n}]\<br>&amp;1&#x3D;\sum_{i&#x3D;1}^n r_{i},</del>0&lt; r_{i}\leq 1,~r_{i} \in \mathbb{R}\<br>\end{aligned}<br>$$<br>要求:</p>
<ol>
<li>寻找一个算法将$N$个元素划分到$n$个区间, 记为$S&#x3D;[S_1,S_2,…,S_n]$, 其中$S_i$为第$i$个区间</li>
<li>元素没有遗漏或被重复划分，每个元素都存在且仅存在于一个划分区间集合内</li>
<li>在满足1 2 的前提下, $(\sum_{i&#x3D;1}^n |num(S_i)-r_{i}N |^{p})^{\frac{1}{p}}$ 取得最小值, 其中, $p \geq 1$, $num(S_i)$为第$i$个区间的元素数, $r_i$为第$i$个区间的划分比率。</li>
</ol>
<h2 id="2-意义与反思"><a href="#2-意义与反思" class="headerlink" title="2. 意义与反思"></a>2. 意义与反思</h2><ol>
<li>可以用来划分机器学习中常常需要使用的训练集, 测试集和验证集等</li>
<li>如果要实现随机划分, 只需要提前shuffle列表即可, 不是本文的讨论核心</li>
<li>如果没有一个好的指标, 那一个造成遗漏或者重复的划分算法, 要考虑会怎么遗漏, 会怎么重复, 如果使用者不知情, 会带来很多不确定性, 影响了确定性算法的应用(从数据集划分上就不确定)</li>
<li>在一个小样本的机器学习背景下, 遗漏或者重复划分一条数据, 往往是致命的, 会造成难以估量的后果</li>
<li>不应当抛弃任何一条数据, 应当尽可能地划分, 不能因为整数除法等原因而导致数据集划分遗漏, 因噎废食</li>
</ol>
<h2 id="3-基本算法描述"><a href="#3-基本算法描述" class="headerlink" title="3. 基本算法描述"></a>3. 基本算法描述</h2><p>给出一个普遍会被想到的办法, 可以按照如下的规则进行划分，记为<code>算法1</code>：</p>
<ol>
<li>以$rates$和$N$得到新列表:<br> $$lst &#x3D; [r_{1}N,r_{2}N,r_{3}N,…,r_{n}N]$$</li>
<li>四舍五入得到:<br> $$round_lst &#x3D; [round(r_{1}N),round(r_{2}N),round(r_{3}N),…,round(r_{n}N)]$$<br> 其中 $round()$ 是四舍五入函数，即：<br> $$<br> \begin{aligned}<br> \forall x \in \mathbb{R},&amp;~round(x)&#x3D;\begin{cases}<br>             \lfloor x\rfloor, &amp;if&amp;x-\lfloor x\rfloor&lt;0.5 \<br>             \lfloor x\rfloor,&amp;if&amp;x-\lfloor x\rfloor&#x3D;0.5,\lfloor x\rfloor \mod 2&#x3D;0\<br>             \lceil x\rceil, &amp;if&amp;x-\lfloor x\rfloor&#x3D;0.5,\lceil x\rceil\mod 2&#x3D; 0\<br>             \lceil x\rceil, &amp;if&amp;x-\lfloor x\rfloor&gt;0.5<br>             \end{cases}\<br> 需要运行环境满足前提条件：\<br> 对&amp;\forall a \in \mathbb{Z^+}有：\<br> &amp; a\equiv float(a)\<br> &amp;a&lt;float(a)+\delta\<br> &amp;a&gt;float(a)-\delta\<br> &amp;其中\delta 为最小的浮点精度(正值)<br> \end{aligned}<br> $$</li>
<li>从列表的第一个元素开始，先取前$round(r_{1}N)$个元素，作为第一块划分，再去接下来的$round(r_{2}N)$个元素，作为第二块划分，以此类推，最后一次，接着上一次取完后的位置，即还没有被划分进前面区间的元素的第一个元素开始，取$round(r_{n}N)$个元素，作为最后一个划分，可划分出$n$个区间。<br> 如果以元素下标的闭区间表示，假设下标都是某个语言下的合理下标时，这$n$个区间可以表示为：<br> $$<br> \begin{aligned}<br> &amp; S_{1} &#x3D; [0,round(r_{1}N)-1]\newline<br> &amp; S_{2} &#x3D; [round(r_{1}N),round(r_{1}N)+round(r_{2}N)-1]\newline<br> &amp; S_{3} &#x3D; [round(r_{1}N)+round(r_{2}N),round(r_{1}N)+round(r_{2}N)+round(r_{3}N)-1]\newline<br> &amp; \dots \newline<br> &amp; S_{n} &#x3D; [\sum_{i&#x3D;1}^{n-1}round(r_{i-1}N),\sum_{i&#x3D;1}^{n}round(r_{i-1}N)-1]<br> \end{aligned}<br> $$</li>
</ol>
<h2 id="4-算法1的问题："><a href="#4-算法1的问题：" class="headerlink" title="4. 算法1的问题："></a>4. 算法1的问题：</h2><p><code>算法1</code>划分的区间是否涵盖了列表的所有元素，即是否:<br>    $$<br>    \begin{aligned}<br>    对:<br>    &amp;~~\forall n,N \in \mathbb{Z^+},~\forall r_{i} \in \mathbb{R}\<br>    满足:\<br>    &amp;n \leq N\<br>    &amp;\sum_{i&#x3D;1}^n r_{i}&#x3D;1\<br>    &amp;0&lt; r_{i}\leq 1\<br>    有:&amp;\sum_{i&#x3D;1}^n round(r_{i}N)\equiv N<br>    \end{aligned}<br>    $$</p>
<p>答案是否定的。</p>
<ul>
<li>假设 $N&#x3D;3$, $rates &#x3D; [0.51,0.24,0.25]$, 则$round_lst&#x3D;[round(1.53),round(0.72),round(0.75)]&#x3D;[2,1,1]$, 此时$\sum_{i&#x3D;1}^n round(r_{i}N)&#x3D;4&gt;3&#x3D;N$, 前两个区间已经覆盖了所有元素，最后一个区间该如何取舍，没有定义</li>
<li>假设 $N&#x3D;3$, $rates &#x3D; [0.51,0.48,0.01]$, 则$round_lst&#x3D;[round(1.53),round(1.44),round(0.03)]&#x3D;[2,1,0]$, 此时$\sum_{i&#x3D;1}^n round(r_{i}N)&#x3D;3&#x3D;N$</li>
<li>假设 $N&#x3D;3$, $rates &#x3D; [0.48,0.48,0.02]$, 则$round_lst&#x3D;[round(1.44),round(1.44),round(0.06)]&#x3D;[1,1,0]$, 此时$\sum_{i&#x3D;1}^n round(r_{i}N)&#x3D;2&lt;3&#x3D;N$，列表最后一个元素没有被任何区间选择</li>
</ul>
<p>因此，<code>算法1</code>并不合理，不仅存在没有覆盖所有元素的可能性，而且没有写清楚应对 $\sum_{i&#x3D;1}^n round(r_{i}N)\equiv N$ 不成立时的应对逻辑，导致以某种语言实现时，依赖于语言特性产生结果，而使用者并不知情。为了设计更加合理的划分方法，我们探究如下问题，记为<code>问题1</code>：</p>
<h2 id="5-问题1："><a href="#5-问题1：" class="headerlink" title="5. 问题1："></a>5. 问题1：</h2><p>$$<br>\begin{aligned}<br>&amp;\mathop{\min}\limits_{n,N,r}<br>\sum_{i&#x3D;1}^n round(r_{i}N)-N\<br>&amp;\mathop{\max}\limits_{n,N,r}<br>\sum_{i&#x3D;1}^n round(r_{i}N)-N\<br>s.t.~~~~~~~~~~&amp;n,N \in \mathbb{Z^+},~n \leq N\</p>
<p>~~~~~~~~~~~~~~&amp;r&#x3D;[r_1,r_2,…,r_n]\in \mathbb{R+^n}\</p>
<p>~~~~~~~~~~~~~~&amp;~~~~|r|_{1}&#x3D;1\</p>
<p>~~~~~~~~~~~~~~&amp;~~~~0&lt; r_{i}\leq 1, i&#x3D;1,2,…,n\<br>\end{aligned}<br>$$<br>其实这是一个最优化问题。但是变量太多，维度太高，我并不会求解。另外，$round()$函数应该算是个阶跃函数，不是凸函数，也不是仿射函数，好像也用不上什么凸优化的结论，当然，因为我学的不深，所以只能打开思路另辟蹊径，后续学会了如何规划，应该就有更好地解释。解法如下：</p>
<p>$$<br>\begin{aligned}<br>设:&amp;r_{i}N &#x3D; a_{i}+b_{i}, 其中a_{i},b_{i}是r_{i}N的整数和浮点拆解\<br>&amp;满足：a_{i}\in \mathbb{Z^+},<del>0\leq b_{i}&lt;1,</del>b_{i} \in \mathbb{R}\<br>&amp;又由于 r_{i}&gt;0\<br>&amp;所以a_{i}+b_{i}&gt;0, 即a_{i},b_{i}不会同时为0\</p>
<p>则:&amp;\sum_{i&#x3D;1}^n a_{i}+\sum_{i&#x3D;1}^n b_{i}\equiv N\</p>
<p>% 当n&#x3D;1 时：&amp;\sum_{i&#x3D;1}^1 a_{i}+\sum_{i&#x3D;1}^1 b_{i}\equiv N\<br>%     必有 &amp;a_1 &#x3D; N, b_1 &#x3D; 0, \sum_{i&#x3D;1}^{n}round(r_{i}N)&#x3D;round(r_{1}N)&#x3D;round(N+0)&#x3D;N \equiv N<del>成立\<br>% 当n&gt;&#x3D;2 时：&amp;\sum_{i&#x3D;1}^2 a_{i}+\sum_{i&#x3D;1}^2 b_{i}\equiv N\<br>%     &amp;0\leq \sum_{i&#x3D;1}^2 b_{i}&lt;2\<br>    另有：&amp; round(a_{i}+b_{i})&#x3D; a_{i}+u_round(b_{i},</del>a_{i}\mod 2)\<br>    其中：&amp; u_round(x,\alpha) &#x3D; \begin{cases}<br>                                &amp;round(x),&amp;if<del>0\leq x&lt; 0.5</del>or<del>0.5&lt; x &lt;1\<br>                                &amp;0, &amp;if</del>x &#x3D; 0.5,\alpha  &#x3D; 0\<br>                                &amp;1,&amp;if~x &#x3D; 0.5, \alpha \neq 0\<br>                                \end{cases} \</p>
<pre><code>所以：&amp; \sum_&#123;i=1&#125;^&#123;n&#125;round(r_&#123;i&#125;N)=\sum_&#123;i=1&#125;^&#123;n&#125;round(a_&#123;i&#125;+b_&#123;i&#125;)=\sum_&#123;i=1&#125;^&#123;n&#125;a_&#123;i&#125;+\sum_&#123;i=1&#125;^&#123;n&#125;u\_round(b_&#123;i&#125;,~a_&#123;i&#125;\mod 2)=N-\sum_&#123;i=1&#125;^&#123;n&#125;b_&#123;i&#125;+\sum_&#123;i=1&#125;^&#123;n&#125;u\_round(b_&#123;i&#125;,~a_&#123;i&#125;\mod 2)\\
即：&amp;\sum_&#123;i=1&#125;^&#123;n&#125;round(r_&#123;i&#125;N)-N = \sum_&#123;i=1&#125;^&#123;n&#125;u\_round(b_&#123;i&#125;,~a_&#123;i&#125;\mod 2)-\sum_&#123;i=1&#125;^&#123;n&#125;b_&#123;i&#125;\\
考察非连续函数&amp;f(b_&#123;1&#125;,b_&#123;2&#125;,...,b_&#123;n&#125;)=\sum_&#123;i=1&#125;^&#123;n&#125;u\_round(b_&#123;i&#125;,~a_&#123;i&#125;\mod 2)-\sum_&#123;i=1&#125;^&#123;n&#125;b_&#123;i&#125;\\

记：&amp;\sum_&#123;i=1&#125;^&#123;n&#125;b_&#123;i&#125;=t\geq 1，显然有N\geq n\geq t+1\\
    &amp;设\&#123;b_&#123;1&#125;,b_&#123;2&#125;,...,b_&#123;n&#125;\&#125;中:\\
    &amp;~~~~在区间[0,0.5)中的b_&#123;i&#125;个数为p_1\\
    &amp;~~~~在恰好为0.5的b_&#123;i&#125;个数为p_2\\
    &amp;~~~~在区间(0.5,1)中的b_&#123;i&#125;个数为p_3\\
    &amp;显然有p_1+p_2+p_3 = t\\
    &amp;且至少满足 p_1\leq 2t-1,~p_2\leq2t\\
    &amp; 若p_2 = 0, 则\\
    &amp;~~~~\sum_&#123;i=1&#125;^&#123;n&#125;u\_round(b_&#123;i&#125;,~a_&#123;i&#125;\mod 2) = p_1\\
    &amp; 若p_2 \geq 1, 则\\
    &amp;~~~~\sum_&#123;i=1&#125;^&#123;n&#125;u\_round(b_&#123;i&#125;,~a_&#123;i&#125;\mod 2)\leq p_1+p_2\\
    &amp;~~~~~~ = 必定可以取得, 原因如下:\\
    &amp;~~~~~~~~设b_&#123;i_0&#125;=0.5,a_&#123;i_0&#125;=2k-1, k \in \mathbb&#123;Z^+&#125;\\
    &amp;~~~~~~~~则u\_round(b_&#123;i&#125;,~a_&#123;i&#125;\mod 2)=0\\
    &amp;~~~~~~~~则必定存在一个N^*=N+1,则a_&#123;i_0&#125;^*=a_&#123;i_0&#125;+1 即可使u\_round(b_&#123;i&#125;,~a_&#123;i&#125;^*\mod 2)=1\\
所以:\\
&amp;max(\sum_&#123;i=1&#125;^&#123;n&#125;u\_round(b_&#123;i&#125;,~a_&#123;i&#125;\mod 2))=max(p1,p1+p2)=2t,~~~~~where~p_1=p_3=0\\
&amp;min(\sum_&#123;i=1&#125;^&#123;n&#125;u\_round(b_&#123;i&#125;,~a_&#123;i&#125;\mod 2))=0, ~~~~~where~p_2=p_3=0\\
所以:\\
&amp;max(f)=max(\sum_&#123;i=1&#125;^&#123;n&#125;u\_round(b_&#123;i&#125;,~a_&#123;i&#125;\mod 2))-t=2t-t=t\\
&amp;min(f)=min(\sum_&#123;i=1&#125;^&#123;n&#125;u\_round(b_&#123;i&#125;,~a_&#123;i&#125;\mod 2))-t=0-t=-t\\
所以：&amp;n确定时\\
    &amp;min(min(f))=min(-t)=-(n-1)\\
    &amp;max(max(f))=max(t)=n-1\\
所以我们有：
    &amp;\mathop&#123;\min&#125;\limits_&#123;n,N,r&#125;
    \sum_&#123;i=1&#125;^n round(r_&#123;i&#125;N)-N=\mathop&#123;\min&#125;\limits_&#123;n&#125;-(n-1)\\
    &amp;\mathop&#123;\max&#125;\limits_&#123;n,N,r&#125;
    \sum_&#123;i=1&#125;^n round(r_&#123;i&#125;N)-N=\mathop&#123;\max&#125;\limits_&#123;n&#125;~~n-1\\
    s.t.~~~~~~~~~~&amp;n,N \in \mathbb&#123;Z^+&#125;,~n \leq N\\
    ~~~~~~~~~~~~~~&amp;r=[r_1,r_2,...,r_n]\in \mathbb&#123;R+^n&#125;\\
    ~~~~~~~~~~~~~~&amp;~~~~\|r\|_&#123;1&#125;=1\\
    ~~~~~~~~~~~~~~&amp;~~~~0&lt; r_&#123;i&#125;\leq 1, i=1,2,...,n\\
即：&amp;当n不确定时，上述问题无解，当固定n时，上述问题解为：\\
    &amp;\mathop&#123;\min&#125;\limits_&#123;N,r&#125;
    \sum_&#123;i=1&#125;^n round(r_&#123;i&#125;N)-N=-(n-1)\\
    &amp;\mathop&#123;\max&#125;\limits_&#123;N,r&#125;
    \sum_&#123;i=1&#125;^n round(r_&#123;i&#125;N)-N=n-1\\
</code></pre>
<p>\end{aligned}<br>$$</p>
<h1 id="6算法调整"><a href="#6算法调整" class="headerlink" title="6算法调整"></a>6算法调整</h1><p>依据<code>问题1</code>讨论出的结论, 应用于<code>算法1</code>，对$N$个元素的列表按照$n$个比例划分，随着各个比例取值的改变，有如下的可能发生：</p>
<ol>
<li>正常划分，每个比率对应的区间都有如使用者预期的元素</li>
<li>至多有$n-1$个划分的区间，每个区间丢失一个元素</li>
<li>至多有$n-1$个划分的区间是空区间</li>
</ol>
<p>因此<code>算法1</code>确实有问题, 也不满足要求, 要求重申:</p>
<ol>
<li>寻找一个算法将$N$个元素划分到$n$个区间, 记为$S&#x3D;[S_1,S_2,…,S_n]$, 其中$S_i$为第$i$个区间</li>
<li>元素没有遗漏或被重复划分，每个元素都存在且仅存在于一个划分区间集合内</li>
<li>在满足1 2 的前提下, $(\sum_{i&#x3D;1}^n |num(S_i)-r_{i}N |^{p})^{\frac{1}{p}}$ 取得最小值, 其中, $p \geq 1$, $num(S_i)$为第$i$个区间的元素数, $r_i$为第$i$个区间的划分比率。</li>
</ol>
<p>难点:</p>
<ol>
<li>四舍五入本就是使得$|X-Y|_{p}, \forall p \geq 1$ 取最小值的办法, 但加上了不能重复或者遗漏元素的前提, 导致简单的四舍五入不适用了</li>
<li>找寻较好的优化方式, 尝试剔除多余的计算,</li>
</ol>
<p>参照<code>算法1</code>按照如下的规则调整，记为<code>算法2</code>：</p>
<ol>
<li><p>以$rates$和$N$得到新列表:<br> $$lst &#x3D; [r_{1}N,r_{2}N,r_{3}N,…,r_{n}N]$$</p>
</li>
<li><p>四舍五入得到:<br> $$round_lst &#x3D; [round(r_{1}N),round(r_{2}N),round(r_{3}N),…,round(r_{n}N)]$$<br> 其中 $round()$ 是四舍五入函数。<br> 同<code>算法1</code>, 依据$round_lst$得到划分区间$S&#x3D;[S_1,S_2,…,S_n]$</p>
</li>
<li><p>计算$nums&#x3D;\sum_{i&#x3D;1}^n round(r_{i}N)-N$，然后</p>
<ul>
<li><p>当 $nums&#x3D;0$ 时，恰好划分</p>
</li>
<li><p>当 $nums \neq 0$ 时:<br>  $$<br>  \begin{aligned}<br>  寻找：&amp; b&#x3D;[b_1,b_2,…,b_n],~b_i \in \mathbb{Z}\<br>  满足：&amp; \sum_{i&#x3D;1}^{n}b_i&#x3D;nums, b_i为划分给区间S_i的新元素数目, S_i区间接受b_i个新元素后, 记为S_i^<em>\<br>  &amp; b_i\geq -round(r_{i}N) \<br>  &amp; num(S_i^</em>) &#x3D; num(S_i)+b_i &#x3D; round(r_{i}N)+b_i\<br>  从而使得:\<br>  &amp;S^*&#x3D;[S_1^*,S_2^*,…,S_n^*]&#x3D;\mathop{\arg\min}\limits_{S}(\sum_{i&#x3D;1}^n |num(S_i)-r_{i}N |^{p})^{\frac{1}{p}}\<br>  \end{aligned}<br>  $$</p>
<p>  $$<br>  \begin{aligned}<br>  由于：&amp; (\sum_{i&#x3D;1}^n |num(S_i^*)-r_{i}N |^{p})^{\frac{1}{p}} &#x3D; (\sum_{i&#x3D;1}^{n} |round(r_{i}N)+b_i-r_{i}N|^{p})^\frac{1}{p}\<br>  \end{aligned}<br>  $$</p>
  <!-- 记函数~&h(x,b) = |round(x)-x+b|, b\in \mathbb{Z},~b \geq 1\\
  则~&\mathop{\sup}\limits_{x} h(x,b)=0.5+b\\
     &\mathop{\min}\limits_{x} h(x,b)=-0.5+b
  \end{aligned} -->
  <!-- 由于对于 |x|^{p}
  + 寻找 $b$ 规则如下:
      + 若 $nums > 0$, 则  --></li>
</ul>
</li>
<li><p>依据$S$,以元素下标的闭区间表示这$n$个划分可以表示为：<br> $$<br> \begin{aligned}<br> &amp;  S_{1} &#x3D; [0,round(r_{1}N)+b_1-1],\newline<br> &amp;  S_{2} &#x3D; [round(r_{1}N)+b_1,round(r_{1}N)+b_1+round(r_{2}N)+b_2-1],\newline<br><br> &amp; \dots \newline<br> &amp;  S_{n} &#x3D; [\sum_{i&#x3D;1}^{n-1}round(r_{i-1}N)+\sum_{i&#x3D;1}^{n-1}b_{i},\sum_{i&#x3D;1}^{n}round(r_{i-1}N)+\sum_{i&#x3D;1}^{n}b_{i}-1]<br> \end{aligned}<br> $$</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/21/Hexo-Hello/" rel="prev" title="Hexo Hello!">
      <i class="fa fa-chevron-left"></i> Hexo Hello!
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">0. 写在前面：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">1. 问题描述:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%84%8F%E4%B9%89%E4%B8%8E%E5%8F%8D%E6%80%9D"><span class="nav-number">3.</span> <span class="nav-text">2. 意义与反思</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="nav-number">4.</span> <span class="nav-text">3. 基本算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%AE%97%E6%B3%951%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">5.</span> <span class="nav-text">4. 算法1的问题：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%97%AE%E9%A2%981%EF%BC%9A"><span class="nav-number">6.</span> <span class="nav-text">5. 问题1：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E7%AE%97%E6%B3%95%E8%B0%83%E6%95%B4"><span class="nav-number"></span> <span class="nav-text">6算法调整</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pu Zhao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pu Zhao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
